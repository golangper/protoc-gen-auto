package plugin

import (
	"fmt"
	"strings"

	descriptor "github.com/gogo/protobuf/protoc-gen-gogo/descriptor"
	"github.com/gogo/protobuf/protoc-gen-gogo/generator"
)


type TsPlugin struct {
	*generator.Generator
	imports map[generator.GoPackageName]generator.GoImportPath

	file *generator.FileDescriptor
}

// Name identifies the plugin
func (p *TsPlugin) Name() string {
	return "rorm"
}

func (p *TsPlugin) Init(g *generator.Generator) {
	p.Generator = g
	p.imports = make(map[generator.GoPackageName]generator.GoImportPath)
}

func (p *TsPlugin) Generate(file *generator.FileDescriptor) {
	p.file = file
	p.P("// Generated by the protocol buffer compiler.  DO NOT EDIT!")
	p.P("// Source:", file.GetName())
	
	p.P(`import { Injectable } from '@angular/core';`)
	p.P(`import { HttpClient, HttpHeaders } from '@angular/common/http';`)
	p.P(`import { Observable } from 'rxjs';`)
	// p.P(`import { catchError } from 'rxjs/operators';`)
	for _, f := range file.Dependency {
		if f != "github.com/golangper/protoc-gen-rorm/options/rorm.proto" && f != "github.com/lyft/protoc-gen-validate/validate/validate.proto" {
			strs := strings.Split(f, "/")
			nm := strs[len(strs)-1]
			hd := strings.Replace(nm, ".proto", "", -1)
			nm = hd + ".pb.service"
			p.P(`import * as `, hd, ` from './`, hd, `.pb.service';`)
		}
	}
	// Messages, recurse.
	for _, msg := range file.MessageType {
		if len(msg.Field) == 0 {
			continue
		}
		
		p.P(`export interface `, generator.CamelCase(msg.GetName()), ` {`)
		p.In()
		for _, field := range msg.GetField() {
			tp := getTsFieldType(field.GetType())
			if tp == "" {
				fmt.Println("not support the type", field.GetType())
				return
			}
			if tp == "Object" {
				s := strings.Split(field.GetTypeName(), ".")
				tp = s[len(s)-1]
			}
			lb := field.GetLabel()
			fname := getFieldName(field.GetName())
			str := fname + "?: " + tp
			if lb == descriptor.FieldDescriptorProto_LABEL_REPEATED {
				str += "[]"
			}
			str += ";"
			p.P(str)
		}
		p.Out()
		p.P(`}`)

	}

	
	p.P(`const httpOptions = {`)
	p.In()
	p.P(`headers: new HttpHeaders({'Content-Type':  'application/json'})`)
	p.Out()
	p.P(`};`)

	for _, svc := range file.GetService() {
		route := GetApiRouteExtension(svc.Options)
		cfg := GetApiCfgExtension(svc.Options)
		if cfg == nil || cfg.Url == "" {
			fmt.Println("must config the api_cfg and url can not be null")
			return
		}
		
		if cfg != nil && cfg.Provide != "" {
			p.P(`@Injectable({`)
			p.In()
			p.P(`providedIn: '`, cfg.Provide,`'`)
			p.Out()
			p.P(`})`)
		} else {
			p.P(`@Injectable()`)
		}
		p.P(`export class `, generator.CamelCase(svc.GetName()), `Service {`)
		p.In()
		p.P(`url = '`, cfg.GetUrl()+route, `';`)
		p.P(`constructor(private http: HttpClient) { }`)
		for _, m := range svc.GetMethod() {
			api := GetApiExtension(m.Options)
			if api != nil {
				mname := m.GetName()
				inputType := generator.CamelCase(m.GetInputType())
				strs := strings.Split(inputType, ".")
				var in, out string
				if file.GetPackage() == strs[1] {
					in = generator.CamelCase(strs[2])
				} else {
					in = strs[1] + "." + generator.CamelCase(strs[2])
				}
				outputType := generator.CamelCase(m.GetOutputType())
				ot := strings.Split(outputType, ".")
				if file.GetPackage() == ot[1] {
					out = generator.CamelCase(ot[2])
				} else {
					out = ot[1] + "." + generator.CamelCase(ot[2])
				}
				msg := p.AllFiles().GetMessage(strs[1], strs[2])

				outmsg := p.AllFiles().GetMessage(ot[1], ot[2])
				if len(outmsg.Field) == 0 {
					out = "{}"
				}
				if len(msg.Field) == 0 {
					p.P(mname, `(): Observable<`, out, `> {`)
				} else {
					p.P(mname, `(param: `, in, `): Observable<`, out, `> {`)
				}
				p.In()
				if api.GetMethod() == `get` || api.GetMethod() == `GET` || api.GetMethod() == `Get` {
					if len(msg.Field) != 0 {
						p.P(`const params = new HttpParams();`)
						for _, f := range msg.Field {
							fname := getFieldName(f.GetName())
							p.P(`params.set('`, fname, `', '' + param.`, fname, `);`)
						}
						p.P(`return this.http.get<`, out, `>(this.url + '`, api.GetPath(), `', {params: params});`)
					} else {
						p.P(`return this.http.get<`, out, `>(this.url + '`, api.GetPath(), `');`)
					}

					// p.P(`  .pipe(`)
					// p.P(`    catchError(this.handleError)`)
					// p.P(`  );`)

				} else if api.GetMethod() == `post` || api.GetMethod() == `Post` || api.GetMethod() == `POST` {
					p.P(`return this.http.post<`, out, `>(this.url + '`, api.GetPath(), `', param, httpOptions);`)
					// p.P(`  .pipe(`)
					// p.P(`    catchError(this.handleError)`)
					// p.P(`  );`)
				}
				p.Out()
				p.P(`}`)
			}
		}
		
		p.Out()
		// p.P(`private handleError(error: HttpErrorResponse) {`)
		// p.P(`console.log('ERROR! ', error);`)
		// p.P(` return throwError('Something bad happened; please try again later.');`)
		// p.P(`}`)
		p.P(`}`)
	}
}

func getFieldName(str string) string {
	s := generator.CamelCase(str)
	f := strings.ToLower(s[:1])
	return string(f) + string(s[1:])
}
func getTsFieldType(typeID descriptor.FieldDescriptorProto_Type) string {
	m := make(map[descriptor.FieldDescriptorProto_Type]string)
	m[descriptor.FieldDescriptorProto_TYPE_DOUBLE] = "number"    // TYPE_DOUBLE
	m[descriptor.FieldDescriptorProto_TYPE_FLOAT] = "number"     // TYPE_FLOAT
	m[descriptor.FieldDescriptorProto_TYPE_INT64] = "number"     // TYPE_INT64
	m[descriptor.FieldDescriptorProto_TYPE_UINT64] = "number"    // TYPE_UINT64
	m[descriptor.FieldDescriptorProto_TYPE_INT32] = "number"     // TYPE_INT32
	m[descriptor.FieldDescriptorProto_TYPE_FIXED64] = "number"   // TYPE_FIXED64
	m[descriptor.FieldDescriptorProto_TYPE_FIXED32] = "number"   // TYPE_FIXED32
	m[descriptor.FieldDescriptorProto_TYPE_BOOL] = "boolean"     // TYPE_BOOL
	m[descriptor.FieldDescriptorProto_TYPE_STRING] = "string"    // TYPE_STRING
	m[descriptor.FieldDescriptorProto_TYPE_MESSAGE] = "Object"   // TYPE_MESSAGE - Length-delimited aggregate.
	m[descriptor.FieldDescriptorProto_TYPE_BYTES] = "Uint8Array" // TYPE_BYTES
	m[descriptor.FieldDescriptorProto_TYPE_UINT32] = "number"    // TYPE_UINT32
	m[descriptor.FieldDescriptorProto_TYPE_ENUM] = "number"      // TYPE_ENUM
	m[descriptor.FieldDescriptorProto_TYPE_SFIXED32] = "number"  // TYPE_SFIXED32
	m[descriptor.FieldDescriptorProto_TYPE_SFIXED64] = "number"  // TYPE_SFIXED64
	m[descriptor.FieldDescriptorProto_TYPE_SINT32] = "number"    // TYPE_SINT32 - Uses ZigZag encoding.
	m[descriptor.FieldDescriptorProto_TYPE_SINT64] = "number"    // TYPE_SINT64 - Uses ZigZag encoding.
	return m[typeID]
}
