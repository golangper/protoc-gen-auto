protoc \
  -I=. \
  -I=${GOPATH}/src \
  -I=${GOPATH}/src/github.com/lyft/protoc-gen-validate \
  -I=${GOPATH}/src/github.com/gogo/protobuf/protobuf \
  --gofast_out=plugins=grpc:. \
  --validate_out="lang=gogo:." \
  --rorm_out=. ./example/prod.proto


proto:

syntax = "proto3";
package example;

import "github.com/golangper/protoc-gen-rorm/options/rorm.proto";
message Prod {
    int64 id = 1;
    string name = 2;
    string details = 3;
    repeated Sku skus = 4;
}

message Sku {
    int64 sku_id = 1;
    float price = 2;
    string bn = 3;
    float weight = 4;
    int64 prod_id = 5;
}
message ProdId{
    int64 id =1;
}
message empty{}
service product {
    option (rorm.sql_type) = 1 ;
    option (rorm.gin_handler) = true ;
    rpc getProd(ProdId) returns (Prod){
        option (rorm.opts) = {
            target: "out";
            method: "sqlx.Get";
            param: "'select * from prod where id = ?';in.id";
            success: {
                target: "out.skus";
                method: "sqlx.Select";
                param: "'select * from sku where prod_id=?';in.id"
            }
        };
    };
    rpc setProd(Prod) returns(empty){
        option (rorm.uid) = {
            name: "uid";
            seed: "in.id"
        };
        option (rorm.opts) = {
            sqlx_tran: [{
                target: "out";
                method: "sqlx.Exec";
                param: "'insert into prod (id,name,details) values (?,?,?)';uid;in.name;in.details"
            },{
                target: "out";
                method: "sqlx.Exec";
                slice: "in.skus";
                param: "'insert into sku (sku_id,price,bn,weight,prod_id) values (?,?,?,?,?)';obj.sku_id;obj.price;obj.bn;obj.weight;in.id"
            }]
        };
    };
}

service:

// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: example/prod.proto

package example

import "golang.org/x/net/context"
import "github.com/jmoiron/sqlx"
import "net/http"
import "github.com/gin-gonic/gin"
import "github.com/gin-gonic/gin/binding"
import "github.com/op/go-logging"

// Reference imports to suppress errors if they are not otherwise used.

type _ProductImp struct {
	db  *sqlx.DB
	log *logging.Logger
}

func (s *_ProductImp) GetProd(c context.Context, in *example.ProdId) (*example.Prod, error) {
	var err error
	out := &example.Prod{}
	err = in.Validate()
	if err != nil {
		return out, err
	}
	err = s.db.Get(out, "select * from prod where id = ?", in.Id)
	if err != nil {
		s.log.Error(err.Error())
		return out, err
	}
	for _, obj := range out {
		err = s.db.Select(&obj.skus, "select * from sku where prod_id=?", in.Id)
	}
	if err != nil {
		s.log.Error(err.Error())
		return out, err
	}
	return out, nil
}

func (s *_ProductImp) SetProd(c context.Context, in *example.Prod) (*example.empty, error) {
	var err error
	out := &example.empty{}
	err = in.Validate()
	if err != nil {
		return out, err
	}
	_s := in.Id % 256
	_worker, err := snowflake.NewChannelWorker(s)
	if err != nil {
		return out, err
	}
	uid, _ := _worker.Next()
	var _ = uid
	tx, err := s.db.Beginx()
	if err != nil {
		s.log.Error(err.Error())
		return out, err
	}
	_, err = s.db.Exec("insert into prod (id,name,details) values (?,?,?)", uid, in.Name, in.Details)
	if err != nil {
		tx.Rollback()
		s.log.Error(err.Error())
		return out, err
	}
	for _, obj := range in.Skus {
		_, err = s.db.Exec("insert into sku (sku_id,price,bn,weight,prod_id) values (?,?,?,?,?)", obj.SkuId, obj.Price, obj.Bn, obj.Weight, in.Id)
		if err != nil {
			tx.Rollback()
			s.log.Error(err.Error())
			return out, err
		}
	}
	tx.Commit()
	return out, nil
}

type ProductImp struct {
	_ProductImp
}

func NewProductImp(db *sqlx.DB, log *logging.Logger) ProductImp {
	res := ProductImp{}
	res.db = db
	res.log = log
	return res
}

func (s *ProductImp) GetProdHandler(c *gin.Context) {
	var prm *example.ProdId
	var err error
	err = c.ShouldBindWith(prm, binding.JSON)
	if err != nil {
		s.log.Error(err.Error())
		c.JSON(http.StatusBadRequest, gin.H{"resp": err.Error()})
		return
	}
	if err = prm.Validate(); err != nil {
		s.log.Error(err.Error())
		c.JSON(http.StatusBadRequest, gin.H{"resp": err.Error()})
		return
	}
	res, err := s.GetProd(context.Background(), prm)
	if err != nil {
		s.log.Error(err.Error())
		c.JSON(http.StatusServiceUnavailable, gin.H{"resp": err.Error()})
		return
	}
	c.JSON(http.StatusOK, gin.H{"resp": res})
}

func (s *ProductImp) SetProdHandler(c *gin.Context) {
	var prm *example.Prod
	var err error
	err = c.ShouldBindWith(prm, binding.JSON)
	if err != nil {
		s.log.Error(err.Error())
		c.JSON(http.StatusBadRequest, gin.H{"resp": err.Error()})
		return
	}
	if err = prm.Validate(); err != nil {
		s.log.Error(err.Error())
		c.JSON(http.StatusBadRequest, gin.H{"resp": err.Error()})
		return
	}
	res, err := s.SetProd(context.Background(), prm)
	if err != nil {
		s.log.Error(err.Error())
		c.JSON(http.StatusServiceUnavailable, gin.H{"resp": err.Error()})
		return
	}
	c.JSON(http.StatusOK, gin.H{"resp": res})
}